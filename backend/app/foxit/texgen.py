"""
DocForge CLI — LaTeX-based PDF generation (advanced template engine).

Alternative to the Foxit Document Generation API for users who need
precise typographic control. The resulting PDF is still post-processed
through the Foxit PDF Services API (watermark, flatten, protect).

Pipeline:
  JSON data → LaTeX template (variable injection) → tectonic compile → PDF
  → Foxit PDF Services API (watermark, flatten, protect) → final PDF

Security:
  - Compilation runs in a temp directory (isolated)
  - Shell escape is disabled (tectonic default)
  - 60-second timeout prevents infinite loops
  - Only the output PDF is read; all temp files are cleaned up
"""

import os
import subprocess
import tempfile
from typing import Any

from app.utils.logging import logger, step_timer

TECTONIC_BIN = os.environ.get("TECTONIC_BIN", "tectonic")
COMPILE_TIMEOUT = 60


def _escape_latex(text: str) -> str:
    """Escape special LaTeX characters in user data."""
    replacements = {
        "&": r"\&",
        "%": r"\%",
        "$": r"\$",
        "#": r"\#",
        "_": r"\_",
        "{": r"\{",
        "}": r"\}",
        "~": r"\textasciitilde{}",
        "^": r"\textasciicircum{}",
    }
    # Don't escape backslashes that are already LaTeX commands
    text = text.replace("\\", r"\textbackslash{}")
    for char, replacement in replacements.items():
        text = text.replace(char, replacement)
    return text


def _build_latex_source(data: dict[str, Any]) -> str:
    """
    Build a complete LaTeX document from release JSON data.
    Variables are injected with proper escaping.
    """
    e = _escape_latex

    product = e(data.get("product_name", "Unknown Product"))
    version = e(data.get("version", "0.0.0"))
    date = e(data.get("release_date", ""))
    summary = e(data.get("summary", "No summary provided."))

    # Build features table rows
    features_rows = ""
    for f in data.get("features", []):
        features_rows += (
            f"    {e(f.get('title', ''))} & {e(f.get('description', ''))} \\\\\n"
            f"    \\hline\n"
        )

    # Build fixes table rows
    fixes_rows = ""
    for f in data.get("fixes", []):
        fixes_rows += (
            f"    {e(f.get('id', ''))} & {e(f.get('title', ''))} & "
            f"{e(f.get('description', ''))} \\\\\n"
            f"    \\hline\n"
        )

    # Build breaking changes rows
    breaking_rows = ""
    for b in data.get("breaking_changes", []):
        breaking_rows += (
            f"    {e(b.get('title', ''))} & {e(b.get('description', ''))} & "
            f"{e(b.get('migration', ''))} \\\\\n"
            f"    \\hline\n"
        )

    # Build links (URLs are NOT escaped — \url{} handles specials)
    links_items = ""
    for lnk in data.get("links", []):
        label = e(lnk.get("label", ""))
        url = lnk.get("url", "").replace("\\textbackslash{}", "\\")
        links_items += f"  \\item {label}: \\url{{{url}}}\n"

    latex = rf"""
\documentclass[11pt,a4paper]{{article}}
\usepackage[utf8]{{inputenc}}
\usepackage[T1]{{fontenc}}
\usepackage{{lmodern}}
\usepackage[margin=1in]{{geometry}}
\usepackage[table]{{xcolor}}
\usepackage{{tabularx}}
\usepackage{{booktabs}}
\usepackage{{hyperref}}
\usepackage{{fancyhdr}}
\usepackage{{titlesec}}

% Colors
\definecolor{{primary}}{{HTML}}{{F2690D}}
\definecolor{{danger}}{{HTML}}{{CC0000}}
\definecolor{{muted}}{{HTML}}{{666666}}

% Header/Footer
\pagestyle{{fancy}}
\fancyhf{{}}
\fancyhead[L]{{\small\color{{muted}}{product} v{version}}}
\fancyhead[R]{{\small\color{{muted}}Release Notes}}
\fancyfoot[C]{{\small\color{{muted}}Generated by DocForge CLI — Powered by Foxit PDF Services API}}
\fancyfoot[R]{{\small\color{{muted}}Page \thepage}}
\renewcommand{{\headrulewidth}}{{0.4pt}}
\renewcommand{{\footrulewidth}}{{0.4pt}}

% Section styling
\titleformat{{\section}}{{\Large\bfseries\color{{primary}}}}{{}}{{0em}}{{}}
\titleformat{{\subsection}}{{\large\bfseries}}{{}}{{0em}}{{}}

\hypersetup{{
    colorlinks=true,
    linkcolor=primary,
    urlcolor=primary,
}}

\begin{{document}}

% Title
\begin{{center}}
    {{\Huge\bfseries {product}}}\\[8pt]
    {{\Large Release Notes --- Version {version}}}\\[6pt]
    {{\color{{muted}}\large Release Date: {date}}}
\end{{center}}

\vspace{{1em}}
\hrule
\vspace{{1.5em}}

% Summary
\section*{{Summary}}
{summary}

\vspace{{1em}}

% Features
\section*{{New Features}}
{f'\n\\begin{{tabularx}}{{\\textwidth}}{{|l|X|}}\n    \\hline\n    \\rowcolor{{primary!10}} \\textbf{{Feature}} & \\textbf{{Description}} \\\\\n    \\hline\n{features_rows}\\end{{tabularx}}' if features_rows else '\\textit{{None}}'}

\vspace{{1em}}

% Bug Fixes
\section*{{Bug Fixes}}
{f'\n\\begin{{tabularx}}{{\\textwidth}}{{|l|l|X|}}\n    \\hline\n    \\rowcolor{{primary!10}} \\textbf{{ID}} & \\textbf{{Title}} & \\textbf{{Description}} \\\\\n    \\hline\n{fixes_rows}\\end{{tabularx}}' if fixes_rows else '\\textit{{None}}'}

\vspace{{1em}}

% Breaking Changes
\section*{{{{\color{{danger}}Breaking Changes}}}}
{f'\n\\begin{{tabularx}}{{\\textwidth}}{{|l|X|X|}}\n    \\hline\n    \\rowcolor{{danger!10}} \\textbf{{Change}} & \\textbf{{Description}} & \\textbf{{Migration}} \\\\\n    \\hline\n{breaking_rows}\\end{{tabularx}}' if breaking_rows else '\\textit{{None}}'}

\vspace{{1em}}

% Links
\section*{{Useful Links}}
{f'\\begin{{itemize}}\n{links_items}\\end{{itemize}}' if links_items else '\\textit{{None}}'}

\end{{document}}
"""
    return latex


async def generate_pdf_from_latex(release_data: dict[str, Any]) -> bytes:
    """
    Build a LaTeX document from release data, compile it with tectonic,
    and return the resulting PDF bytes.

    The PDF is then passed through the Foxit PDF Services pipeline
    for watermarking, flattening, and protection.
    """
    with step_timer("Build LaTeX source"):
        latex_source = _build_latex_source(release_data)
        logger.info("  LaTeX source: %d characters", len(latex_source))

    with step_timer("Compile LaTeX → PDF (tectonic)"):
        with tempfile.TemporaryDirectory(prefix="docforge-tex-") as tmpdir:
            tex_path = os.path.join(tmpdir, "release-notes.tex")
            pdf_path = os.path.join(tmpdir, "release-notes.pdf")

            with open(tex_path, "w", encoding="utf-8") as f:
                f.write(latex_source)

            try:
                result = subprocess.run(
                    [TECTONIC_BIN, "--keep-logs", tex_path],
                    capture_output=True,
                    text=True,
                    timeout=COMPILE_TIMEOUT,
                    cwd=tmpdir,
                )
            except FileNotFoundError:
                raise RuntimeError(
                    "tectonic is not installed. Install with: brew install tectonic"
                )
            except subprocess.TimeoutExpired:
                raise RuntimeError(
                    f"LaTeX compilation timed out after {COMPILE_TIMEOUT}s"
                )

            if result.returncode != 0:
                error_lines = [
                    line for line in result.stderr.split("\n")
                    if "error" in line.lower() or "!" in line
                ][:10]
                error_msg = "\n".join(error_lines) or result.stderr[-500:]
                logger.error("  tectonic failed:\n%s", error_msg)
                raise RuntimeError(f"LaTeX compilation failed:\n{error_msg}")

            if not os.path.exists(pdf_path):
                raise RuntimeError("tectonic produced no output PDF")

            with open(pdf_path, "rb") as f:
                pdf_bytes = f.read()

            logger.info("  Compiled %d bytes PDF from LaTeX", len(pdf_bytes))
            return pdf_bytes
